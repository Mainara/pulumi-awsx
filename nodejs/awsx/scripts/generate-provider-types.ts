import * as pulumiSchema from "./pulumi-schema";
import * as fs from "fs";
import * as ts from "typescript";
import path = require("path");

/*
 TODO:
 - Complex types
 - Ref types
 - Type docs
 - Property docs
 - Abstract constructor
 */

const headerWarning = `This file was automatically generated by pulumi-provider-scripts.
DO NOT MODIFY IT BY HAND. Instead, modify the source Pulumi Schema file,
and run "pulumi-provider-scripts gen-provider-types" to regenerate this file.`;

const getType = (typeDefinition: pulumiSchema.TypeReference) => {
    switch (typeDefinition.type) {
        case "string":
            return ts.factory.createKeywordTypeNode(
                ts.SyntaxKind.StringKeyword,
            );
        case "integer":
        case "number":
            return ts.factory.createKeywordTypeNode(
                ts.SyntaxKind.NumberKeyword,
            );
        case "boolean":
            return ts.factory.createKeywordTypeNode(
                ts.SyntaxKind.BooleanKeyword,
            );
        case "array":
            return ts.factory.createArrayTypeNode(
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
            );
        case "object":
            return ts.factory.createTypeReferenceNode("Record", [
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
            ]);
    }
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
};

function genTypeProperties(
    properties?: Record<string, pulumiSchema.TypeReference>,
    required?: string[],
): ts.TypeElement[] {
    if (properties === undefined) {
        return [];
    }
    const requiredLookup = new Set(required);
    return Object.entries(properties).map(
        ([propKey, typeDefinition]): ts.TypeElement => {
            const type = getType(typeDefinition);

            return ts.factory.createPropertySignature(
                [ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
                propKey,
                requiredLookup.has(propKey)
                    ? undefined
                    : ts.factory.createToken(ts.SyntaxKind.QuestionToken),
                type,
            );
        },
    );
}

function genClassProperties(
    properties?: Record<string, pulumiSchema.TypeReference>,
    required?: string[],
) {
    if (properties === undefined) {
        return [];
    }
    const requiredLookup = new Set(required);
    return Object.entries(properties).map(([propKey, typeDefinition]) => {
        const type = getType(typeDefinition);
        return ts.factory.createPropertyDeclaration(
            undefined,
            [ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
            propKey,
            requiredLookup.has(propKey)
                ? ts.factory.createToken(ts.SyntaxKind.ExclamationToken)
                : ts.factory.createToken(ts.SyntaxKind.QuestionToken),
            type,
            undefined,
        );
    });
}

const genResourceArgs = (
    typeName: string,
    resource: pulumiSchema.ObjectTypeDefinition,
): ts.InterfaceDeclaration => {
    const inputProperties = genTypeProperties(
        resource.inputProperties as any,
        resource.requiredInputs as any,
    );
    const inputs = ts.factory.createInterfaceDeclaration(
        undefined,
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        typeName + "Args",
        undefined,
        undefined,
        inputProperties,
    );

    return inputs;
};

const genResourceAbstractType = (
    typeName: string,
    resource: pulumiSchema.ObjectTypeDefinition,
) => {
    const heritage = ts.factory.createHeritageClause(
        ts.SyntaxKind.ExtendsKeyword,
        [
            ts.factory.createExpressionWithTypeArguments(
                ts.factory.createPropertyAccessChain(
                    ts.factory.createIdentifier("pulumi"),
                    undefined,
                    "ComponentResource",
                ),
                undefined,
            ),
        ],
    );
    const constructor = ts.factory.createConstructorDeclaration(
        undefined,
        undefined,
        [],
        undefined,
    );
    const resourceType = ts.factory.createClassDeclaration(
        undefined,
        [
            ts.factory.createModifier(ts.SyntaxKind.ExportKeyword),
            ts.factory.createModifier(ts.SyntaxKind.AbstractKeyword),
        ],
        typeName + "Outputs",
        undefined,
        [heritage],
        [
            ...genClassProperties(
                resource.properties as any,
                resource.required as any,
            ),
            // constructor,
        ],
    );

    return resourceType;
};

const genTypeInterfaces = (
    typeName: string,
    resource: pulumiSchema.TypeDefinition,
): ts.InterfaceDeclaration[] => {
    const inputProperties = genTypeProperties(
        resource.inputProperties as any,
        resource.requiredInputs as any,
    );
    const inputs = ts.factory.createInterfaceDeclaration(
        undefined,
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        typeName + "Inputs",
        undefined,
        undefined,
        inputProperties,
    );

    const outputProperties = genTypeProperties(
        resource.properties as any,
        resource.required as any,
    );
    const outputs = ts.factory.createInterfaceDeclaration(
        undefined,
        [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        typeName + "Outputs",
        undefined,
        undefined,
        outputProperties,
    );

    return [inputs, outputs];
};

function getTypeName(typeToken: string) {
    const tokenParts = typeToken.split(":");
    const typeName = tokenParts[2];
    return typeName;
}

function genResources(
    resources: pulumiSchema.PulumiPackageMetaschema["resources"],
) {
    return Object.entries(resources ?? {}).flatMap(([typeToken, resource]) => {
        const typeName = getTypeName(typeToken);
        return [
            genResourceAbstractType(typeName, resource),
            genResourceArgs(typeName, resource),
        ];
    });
}

function genTypes(resources: pulumiSchema.PulumiPackageMetaschema["types"]) {
    return Object.entries(resources ?? {}).flatMap(([key, value]) =>
        genTypeInterfaces(getTypeName(key), value),
    );
}

export function generateProviderTypes(args: { schama: string; out: string }) {
    const schemaPath = path.resolve(args.schama);
    const schemaText = fs.readFileSync(schemaPath, { encoding: "utf-8" });
    const schema: pulumiSchema.PulumiPackageMetaschema = JSON.parse(schemaText);

    const nodes = ts.factory.createNodeArray([
        ts.factory.createJSDocComment(headerWarning),
        ts.factory.createImportDeclaration(
            undefined,
            undefined,
            ts.factory.createImportClause(
                false,
                ts.factory.createIdentifier("* as pulumi"),
                undefined,
            ),
            ts.factory.createStringLiteral("@pulumi/pulumi"),
        ),
        ...genResources(schema.resources),
        ...genTypes(schema.types),
    ]);
    const sourceFile = ts.createSourceFile(
        "provider-types.d.ts",
        "",
        ts.ScriptTarget.ES2019,
        undefined,
        ts.ScriptKind.TS,
    );

    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    const result = printer.printList(
        ts.ListFormat.MultiLine,
        nodes,
        sourceFile,
    );

    const outPath = path.resolve(args.out);
    fs.writeFileSync(outPath, result);
}

generateProviderTypes({
    schama: "../../provider/cmd/pulumi-resource-awsx/schema.json",
    out: "schema-types.ts",
});
